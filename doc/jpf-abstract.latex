\documentclass{article}

\usepackage{graphics}
\usepackage{listings}
\usepackage[cm]{fullpage}
\usepackage{syntax}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{placeins}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{ulem}

\lstset{language=Java}

% Variable
\def\var#1{{\tt \bf #1}}

% Access path
\def\ap#1#2#3{%
{\tt \var{#1}.%
\edef\p{#2}%
\edef\e{}%
\ifx\p\e%
\else%
#2.%
\fi%
#3}%
}


\begin{document}

\title{Predicate Abstraction in JPF}

\maketitle

The main goal is to support important features of Java (objects, classes, fields, arrays, local variables) and predicates over variables that have numerical data types.
We consider primitive types (byte, short, char, int, long, float, double) and also wrapper classes (Integer, Double, etc).

\section*{Predicate language}

The predicate language must be rich enough to support the following: classes, objects, static fields, instance fields, local variables (including method parameters), arrays, and array elements.
Syntax of the predicates is captured by this grammar:

\begin{grammar}
<predicate> ::= `not' `(' <predicate> `)'
    \alt `true'
    \alt `false'
    \alt <expression> `=' <expression>
    \alt <expression> `\textless' <expression>

<expression> ::= <term>
    \alt <term> `+' <term>
    \alt <term> `-' <term>

<term> ::= <factor>
    \alt <factor> `*' <factor>
    \alt <factor> `/' <factor>

<factor> ::= "constant"
    \alt <dotpath>
    \alt <funpath>
    \alt `(' <expression> `)'

<dotpath> ::= <dotpath> `.' "fieldname"
    \alt <dotpath> `[' <expression> `]'
    \alt "classname" `.' "fieldname"
    \alt "varname"

<funpath> ::= `fread' `(' "fieldname" `,' <funpath> `)'
    \alt `aread' `(' `arr', `,' <funpath> `,' <expression> `)'
    \alt `fread' `(' "fieldname" `,' "classname" `)'
    \alt "varname"
\end{grammar}

The dot-notation (\ap{a}{b}{f}) is a syntactic sugar for the internal notation based on functions (fread, aread).
All expressions with dots will be translated into the functions-based notation internally.

The grammar does not include logic operators (and, or) and quantifiers, because we do not care much about properties here.
Formulas that represent properties over arrays typically involve quantifiers.

\subsection*{Identifiers}

The first element (root) of an access path is a local variable name (including \texttt{this}) or a class name.
If some element of an access path is a variable or field of a reference type, then its value uniquely identifies the respective object by its heap address (objRef).
The last element of an access path must be an expression (local variable, field, array element) of a numeric type (primitive, wrapper class), otherwise the whole expression does not make sense for us.

We must also consider the scope of local variables. 
If some predicate contains an expression \ap{a}{}{f}, where \var{a} is a local variable of some method {\it m}, then the predicate is defined only in the scope of the method {\it m}.

One predicate can refer to fields of different objects. 
Example: \ap{this}{o1}{f} \textless \ \ap{p1}{}{g}, where \var{p1} is a method parameter (an object different from \ap{this}{}{o1}).

If a given predicate refers only to object fields (not local variables of some method), such as \ap{this}{}{f1} \textless \ \ap{this}{}{f2}, then it will be defined during method calls on the given object.

\section*{Abstract State}

An \textit{abstract state} is the valuation (truth value) of all individual predicates defined in the current context (scope).

\vspace{\baselineskip}

Each predicate evaluates to $\left\{ \begin{array}{lcl}\text{\tt undefined} &\sim& \text{\it referring to out-of-scope variables} \\ \text{\tt 0} &\sim& \text{\tt false} \\ \text{\tt 1} &\sim& \text{\tt true} \\ \text{\tt unknown (*)} &\sim& \text{\tt TOP} \end{array} \right.$

\begin{figure}[!h]
  \centering
  \includegraphics{figure0}
\end{figure}

In each state, we will store valuations of all predicates defined in the current scope. We will preserve the concrete values too (i.e., not setting them to 0 like in the original Abstract Pathfinder), because they may be useful in deciding values of certain predicates (see below) with the SMT solver.

We will use a {\bf single global container} for current values of all predicates. Values will not be stored in attributes for objects, fields, and local variables (stack frame slots).
The container is a map from predicates to their values.
This approach has several benefits:
\begin{itemize}
	\item avoiding redundancy (no need to store values at two different locations if the given predicate refers to two local variables or instance fields),
	\item consistency (when the predicate value is stored at one place), and
	\item easy access to current values for all predicates (over all objects)
\end{itemize}

\vspace{\baselineskip}
 
For each value on the current stack frame (context, scope) that represents an object reference, we must know the access path through which we acquired the value, so that we can find the corresponding predicates.
The access path can be a local variable name, or a local variable name followed by a sequence of field names.
We will keep the access path for a given value on the stack in its attribute.
If we have the value $v$ on the top of the stack frame and its access path \ap{this}{}{f} in the attribute for $v$, and JPF executes a getfield instruction on $v$ and the field \texttt{g}, the new value on the top of the stack frame will be $w$ and its access path will be \ap{this}{f}{g} --- then we know that a predicate referring to \ap{this}{f}{g} applies to $w$.

\subsection*{Updating}

Truth values of some predicates are updated either when the current scope changes (call, return) or when JPF executes some data-manipulation instruction (getfield, iadd, etc).
For each instruction we must update (process) only the predicates affected by the instruction. We identify relevant predicates using the access paths for the instruction operands.
Original value is preserved for other (unaffected) predicates.
This may save a considerable number of calls to the SMT solver.

However, there are still difficult challenges.
The following example demonstrates the case when we have two different access paths lead to the same object.
The field \texttt{f} of a given object of the class \texttt{ClassZ} is accessible through \ap{a}{y.z}{f} and \ap{b}{z}{f}.
If JPF executes an instruction that uses \ap{a}{y.z}{f}, then we must update truth value of predicates over \ap{a}{y.z}{f} and also predicates over \ap{b}{z}{f}.

\begin{lstlisting}
  public void m(ClassX a) {
    ClassY b = a.y;
    ... 
    a.y.z.f = 5;
    ...
    b.z.f = x + 1;
    ...
  }
\end{lstlisting}

\begin{figure}[!h]
  \centering
  \includegraphics{figure1}
\end{figure}

We also need a map from object references (ElementInfo) to all access paths that refer to a given object. Using this map we can find aliased access paths and then predicates which must be updated.





% TODO

\noindent\textbf{TODO}

		- jmena lokalnich promennych mozna zjistime pres StackFrame (kdyz bude prislusny class file obsahovat debugovaci symboly)

		- behem state space traversal bude JPF obsah toho containeru vhodne updatovat (backtracking) a take serializovat (na state matching)
		- it will be properly managed (backtracking)

		- truth value of predicates that refer only to object fields should be preserved between different method calls on the object

	- pouzite mechanismy: bytecode instructions, serialization, apod
	
	- state matching over predicates -> nejspis pouzit SMT solver (jako symbolic execution) nebo jinak checkovat subsumption
		- pro stavy s1 a s2, kde s1 je "already visited before" a s2 je current state, vyrobit logicke formule na zaklade truth value predikatu a zavolat solver, aby otestoval platnost implikace "s1 => s2"
		- musime upravit serializer tak, aby pro danou variable ignoroval konkretni hodnoty, pokud existuje nejaky predikat 
		- najit existujici clanky (related work) -> hlavne abstract state matching with subsumption for symbolic execution

	- method call: truth values of predicates over "this" and formal method parameters must be set according to truth values of predicates over actual parameters

	- we can probably allow mixing predicate abstraction with numeric abstractions (signs, etc) -> use the same instruction factory
	- how to use the SMT solver: prepare input (string), execute system process, and parse output ("sat", "unsat")
	- kdyz najdeme v dynamic program state aktualni hodnotu nejake promenne, tak ji muzeme pouzit v logicke formuli (input for SMT) jako dalsi constraint
		- example: predikat "a[i] > x" a constraint "a[i] = 5" vyrobena na zaklade dynamic state
	- rozmyslet dobre jestli navrzene pouziti globalniho containeru pro ukladani abstract values nezpusobi problemy



\section*{Usage / Running}

Input: a set of predicates defined in a textual file whose name (path) is passed as an argument to the selected predicate abstraction in a .jpf file.
	define predicates over local variables of each method separately, and for each class (predicates over static fields and instance fields)

	Each predicate must be associated with some class (for predicates that refer only to fields) or with some method (for predicates that refer also to local variables).



\begin{itemize}

	\item 

  \begin{itemize}
  \item {\bf Requirements}
    \begin{itemize}
    \item Maintenance (backtracking, instruction execution \ldots)
    \item Serialisation (state matching)
    \end{itemize}


    \FloatBarrier

    \begin{figure}[!h]
    \centering
    \includegraphics{figure2}
    \end{figure}

    \FloatBarrier

    \newpage
    Resolve all paths used in a concrete predicate:
    \begin{itemize}
    \item defined $\Rightarrow$ add clause $\text{\tt path} = value$
    \item undefined $\Rightarrow$ predicate undefined
    \end{itemize}

    \begin{algorithm}
    \begin{algorithmic}
    \Procedure{updatePredicates}{$Predicates, Valuation, AffectedPaths$}
    \ForAll{$p \in Predicates$}
      \If{$AffectedPaths \cap usedPaths(p) \neq \emptyset$}
        \State $Valuation \gets Valuation \oplus p \mapsto evalPredicate(p)$
      \EndIf
    \EndFor
    \EndProcedure
    \end{algorithmic}
    \end{algorithm}

    \begin{algorithm}
    \begin{algorithmic}
    \Function{evalPredicate}{$P$}
    \State $Q \gets P$
    \ForAll{$p \in usedPaths(P)$}
      \State $e \gets pathToElementInfo(p)$
      \State $v \gets getValue(e)$
      \State $Q \gets Q \wedge p = v$
    \EndFor
    \Return $SMT(Q)$
    \EndFunction
    \end{algorithmic}
    \end{algorithm}

    \FloatBarrier


\end{itemize}

\section*{Implementation: Extension to JPF Abstraction}

\item Implementation mechanisms

  \begin{itemize}
  \item Bytecode instructions
  \item Serialisation
  \item Attribute system
  \item \ldots
  \item AbstractValue (if not proven to have unsuitable interface)
  \item AbstractInstructionFactory (co-existence with other abstractions)
  \item Scope-aware Map: access path $p$ to {\tt e} $\mapsto$ primitive {\tt ElementInfo e}
  \item Scope-aware Map: $\text{primitive \tt ElementInfo e} \mapsto \left\{p\:\middle\vert\:p\:\text{access path to \tt e}\right\}$
  \end{itemize}

\item Mapping variables / class names to concrete ElementInfo / ClassInfo objects in concrete scope.

Needed to be able to provide SMT with fixed values of referred variables.
The mapping needs to allow looking up corresponding ElementInfo's for a given access path (To allow use of concrete values in predicates to capture current state) but also for a given ElementInfo all possible currently valid access paths (To allow filtering out affected predicates for re-evaluation).

  Choose one of:
  \begin{itemize}
  \item provide a dictionary of our own

    {\bf Pros:}
    \begin{itemize}
    \item Fast (Hash tables or other dictionary-like structures instead of arrays)
    \end{itemize}

    {\bf Cons:}
    \begin{itemize}
    \item Need to handle backtracking and scoping in general
    \end{itemize}
  \item extract needed information from ThreadInfo, StackFrame and VM
    \begin{itemize}
    \item {\bf Fields:} ThreadInfo.getElementInfo, StackFrame.getThis, ElementInfo.getClassInfo, ClassInfo.getInstanceField
    \item {\bf Locals:} StackFrame.getLocalVars
    \item {\bf Static:} VM.getClassLoaderList, ClassLoaderInfo.loadedClasses, ClassInfo.getStatics \ldots
    \end{itemize}

    {\bf Pros:}
    \begin{itemize}
    \item Existing code
    \item State maintained over backtracking / \ldots
    \end{itemize}

    {\bf Cons:}
    \begin{itemize}
    \item One-way (Path to ElementInfo)
    \item {\it Need of debugging symbols ???}
    \end{itemize}
    
  \end{itemize}

\item SMT - invoked as a separate process

Use:
\begin{itemize}
\item at update of the abstract value
\item at branch choice
\item state matching over predicates

  $s_1, s_2$ states, $s_1$ already visited, $s_2$ current. Determine whether $s_1 \sim s_2$ (Subsumption). \\

  Test whether $s_2$ is already visited based on truth values of the predicates. 
  One option is to create formulas and use SMT to decide.

  Assume $PC(s_1) = PC(s_2)$ otherwise $s_1 \not \sim s_2$.

  We will check related work, especially abstract state matching with subsumption for symbolic execution.

%  Example: \\
%
%  $s_1$:
%  \begin{itemize}
%  \item $P_1$
%  \item $\neg P_2$
%  \item $P_3$
%  \item $P_4$ unknown
%  \end{itemize}
%
%  $s_2$:
%  \begin{itemize}
%  \item $P_1$
%  \item $\neg P_2$
%  \item $P_3$ undefined
%  \item $P_4$
%  \end{itemize}

%  SMT: $s_1 \Rightarrow sdd_2$ ?\\

%  If $s_2$ is a consequence of $s_1$ which we have already visited then it is impossible to infer anything new (branching etc.).
%  The new state is therefore effectively equivalent.
\end{itemize}

Choices:
\begin{itemize}
\item {\bf MathSAT 5} - accepts SMT-LIB format and DIMACS format
\item Yices
\item \ldots
\end{itemize}

\end{itemize}

\end{document}
