\documentclass{article}

\usepackage{graphics}
\usepackage{listings}
\usepackage[cm]{fullpage}
\usepackage{syntax}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{placeins}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{ulem}

\lstset{language=Java}

% Variable
\def\var#1{{\tt \bf #1}}

% Access path
\def\ap#1#2#3{%
{\tt \var{#1}.%
\edef\p{#2}%
\edef\e{}%
\ifx\p\e%
\else%
#2.%
\fi%
{\it #3}}%
}

\begin{document}

\section*{JPF Predicate Abstraction}

\begin{itemize}

\item Predicates defined per program

Defined in a textual file whose name (path) is passed as an argument to the selected predicate abstraction in a .jpf file.

\item Focus solely on numerical data types (byte, char, short, int, long, float, double)
\item Predicate language rich enough to support objects, classes, arrays
  \begin{itemize}
    \item local variables (including method parameters)
    \item static fields
    \item object fields
    \item array elements
  \end{itemize}

  Ensured by allowing proper terms in formulas.

\end{itemize}

\section*{Predicate language}

\begin{grammar}
<predicate> ::= `not' `(' <predicate> `)'
    \alt `(' <predicate> `and' <predicate> `)'
    \alt `(' <predicate> `or'  <predicate> `)'
    \alt `true'
    \alt `false'
    \alt <expression> `=' <expression>
    \alt <expression> `\textless' <expression>

<expression> ::= <term>
    \alt <term> `+' <term>
    \alt <term> `-' <term>

<term> ::= <factor>
    \alt <factor> `*' <factor>
    \alt <factor> `/' <factor>

<factor> ::= "constant"
    \alt <path>
    \alt <altpath>
    \alt `(' <expression> `)'

<path> ::= <path> `.' "fieldname"
    \alt <path> `[' "index" `]'
    \alt "classname" `.' "staticfieldname"
    \alt "varname"

<altpath> ::= `field' `(' <altpath> `,' "fieldname" `)'
    \alt `array' `(' <altpath> `,' "index" `)'
    \alt `field' `(' "classname" `,' "staticfieldname" `)'
    \alt "varname"
\end{grammar}

The dot-notation (\ap{a}{b}{f}) is a syntactic sugar for the notation based on function calls. All expressions with dots will be translated into the function-notation internally.

\subsection*{Identifiers - Variable/Field/Class names}

The root element of an access path is always an identifier of an instance (local or static). 
If some element of the access path is a variable of a reference type, then its value uniquely identifies the object (by its heap address (objRef)).
Field names and array indices follow.
Every path ends in a primitive-typed field / element (or its wrapper: Integer, Double, Float \ldots ?) otherwise the whole expression does not make sense.

We will also consider the scope of variables. If some predicate contains an expression \ap{a}{}{f}, where \var{a} is a local variable of some method {\it m}, then the predicate is defined only in the scope of the method {\it m}.


\subsection*{SMT-LIB Lisp-like syntax}

Not very effective from manual-maintenance point of view.

\section*{Extension to JPF Abstraction}

\begin{itemize}
\item {\bf Abstract value} $\sim$ valuation of individual predicates
\item Predicates evaluate to $\left\{ \begin{array}{lcl}\text{\tt undefined} &\sim& \text{\it referring to out-of-scope variables} \\ \text{\tt 0} &\sim& \text{\tt false} \\ \text{\tt 1} &\sim& \text{\tt true} \\ \text{\tt unknown (*)} &\sim& \text{\tt TOP} \end{array} \right. $

  \begin{figure}[!h]
  \centering
  \includegraphics{figure0}
  \end{figure}

  \FloatBarrier

\item Concrete value kept unmodified for SMT purposes
\item {\bf Global abstraction} - There is a single valuation of all input predicates shared between all the abstract values (attributes to all the concrete values)
  \begin{figure}[!h]
  \centering
  \includegraphics{figure3}
  \end{figure}

  \FloatBarrier

  \begin{itemize}
  \item {\bf Benefits}
    \begin{itemize}
    \item Avoids redundancy (No need to have two truth value estimates for a single predicate stored in two different abstract values)
    \item Implies consistency (No differences)
    \item Provides accessibility to the most extensive information for all the abstract values
    \end{itemize}

  \item {\bf Requirements}
    \begin{itemize}
    \item Maintenance (backtracking, instruction execution \ldots)
    \item Serialisation (state matching)
    \end{itemize}

  \item {\bf Update}
    \begin{itemize}
    \item Invoked by change of scope
    \item Invoked by instruction execution

    Predicate determines what access paths it depends on.
    Only predicates depending on paths affected by a given instruction are updated.
    Unaffected predicates keep their value.
    This may save a considerable number of SMT invocations. \\

    The following example demonstrates challenges that severely affect the design of our solution.

    \begin{lstlisting}
    public void m(ClassX a) {
      ClassY b = a.y;
      ... a.y.z.field + b.z.field ...
    }
    \end{lstlisting}

    \begin{figure}[!h]
    \centering
    \includegraphics{figure1}
    \end{figure}

    \FloatBarrier

    \begin{figure}[!h]
    \centering
    \includegraphics{figure2}
    \end{figure}

    \FloatBarrier

    \newpage
    Resolve all paths used in a concrete predicate:
    \begin{itemize}
    \item defined $\Rightarrow$ add clause $\text{\tt path} = value$
    \item undefined $\Rightarrow$ predicate undefined
    \end{itemize}

    \begin{algorithm}
    \begin{algorithmic}
    \Procedure{updatePredicates}{$Predicates, Valuation, AffectedPaths$}
    \ForAll{$p \in Predicates$}
      \If{$AffectedPaths \cap usedPaths(p) \neq \emptyset$}
        \State $Valuation \gets Valuation \oplus p \mapsto evalPredicate(p)$
      \EndIf
    \EndFor
    \EndProcedure
    \end{algorithmic}
    \end{algorithm}

    \begin{algorithm}
    \begin{algorithmic}
    \Function{evalPredicate}{$P$}
    \State $Q \gets P$
    \ForAll{$p \in usedPaths(P)$}
      \State $e \gets pathToElementInfo(p)$
      \State $v \gets getValue(e)$
      \State $Q \gets Q \wedge p = v$
    \EndFor
    \Return $SMT(Q)$
    \EndFunction
    \end{algorithmic}
    \end{algorithm}

    \FloatBarrier


  \end{itemize}
\end{itemize}

\item Implementation mechanisms

  \begin{itemize}
  \item Bytecode instructions
  \item Serialisation
  \item Attribute system
  \item \ldots
  \item AbstractValue (if not proven to have unsuitable interface)
  \item AbstractInstructionFactory (co-existence with other abstractions)
  \item Scope-aware Map: access path $p$ to {\tt e} $\mapsto$ primitive {\tt ElementInfo e}
  \item Scope-aware Map: $\text{primitive \tt ElementInfo e} \mapsto \left\{p\:\middle\vert\:p\:\text{access path to \tt e}\right\}$
  \end{itemize}

\item Mapping variables / class names to concrete ElementInfo / ClassInfo objects in concrete scope.

Needed to be able to provide SMT with fixed values of referred variables.
The mapping needs to allow looking up corresponding ElementInfo's for a given access path (To allow use of concrete values in predicates to capture current state) but also for a given ElementInfo all possible currently valid access paths (To allow filtering out affected predicates for re-evaluation).

  Choose one of:
  \begin{itemize}
  \item provide a dictionary of our own

    {\bf Pros:}
    \begin{itemize}
    \item Fast (Hash tables or other dictionary-like structures instead of arrays)
    \end{itemize}

    {\bf Cons:}
    \begin{itemize}
    \item Need to handle backtracking and scoping in general
    \end{itemize}
  \item extract needed information from ThreadInfo, StackFrame and VM
    \begin{itemize}
    \item {\bf Fields:} ThreadInfo.getElementInfo, StackFrame.getThis, ElementInfo.getClassInfo, ClassInfo.getInstanceField
    \item {\bf Locals:} StackFrame.getLocalVars
    \item {\bf Static:} VM.getClassLoaderList, ClassLoaderInfo.loadedClasses, ClassInfo.getStatics \ldots
    \end{itemize}

    {\bf Pros:}
    \begin{itemize}
    \item Existing code
    \item State maintained over backtracking / \ldots
    \end{itemize}

    {\bf Cons:}
    \begin{itemize}
    \item One-way (Path to ElementInfo)
    \item {\it Need of debugging symbols ???}
    \end{itemize}
    
  \end{itemize}

\item SMT - invoked as a separate process

Use:
\begin{itemize}
\item at update of the abstract value
\item at branch choice
\item state matching over predicates

  $s_1, s_2$ states, $s_1$ already visited, $s_2$ current. Determine whether $s_1 \sim s_2$ (Subsumption). \\

  Test whether $s_2$ is already visited based on truth values of the predicates. 
  One option is to create formulas and use SMT to decide.

  Assume $PC(s_1) = PC(s_2)$ otherwise $s_1 \not \sim s_2$.

  We will check related work, especially abstract state matching with subsumption for symbolic execution.

%  Example: \\
%
%  $s_1$:
%  \begin{itemize}
%  \item $P_1$
%  \item $\neg P_2$
%  \item $P_3$
%  \item $P_4$ unknown
%  \end{itemize}
%
%  $s_2$:
%  \begin{itemize}
%  \item $P_1$
%  \item $\neg P_2$
%  \item $P_3$ undefined
%  \item $P_4$
%  \end{itemize}

%  SMT: $s_1 \Rightarrow sdd_2$ ?\\

%  If $s_2$ is a consequence of $s_1$ which we have already visited then it is impossible to infer anything new (branching etc.).
%  The new state is therefore effectively equivalent.
\end{itemize}

Choices:
\begin{itemize}
\item {\bf MathSAT 5} - accepts SMT-LIB format and DIMACS format
\item Yices
\item \ldots
\end{itemize}

\end{itemize}

\end{document}
