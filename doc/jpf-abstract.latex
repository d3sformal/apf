\documentclass{article}

\usepackage{graphics}
\usepackage{listings}
\usepackage[cm]{fullpage}
\usepackage{syntax}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{placeins}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{ulem}

\lstset{language=Java}

% Variable
\def\var#1{{\tt \bf #1}}

% Access path
\def\ap#1#2#3{%
{\tt \var{#1}.%
\edef\p{#2}%
\edef\e{}%
\ifx\p\e%
\else%
#2.%
\fi%
{\it #3}}%
}

\begin{document}

\section*{JPF Predicate Abstraction}

\begin{itemize}

\item Predicates defined per program

Defined in a textual file whose name (path) is passed as an argument to the selected predicate abstraction in a .jpf file.

\item Focus solely on numerical data types (byte, char, short, int, long, float, double)
\item Predicate language rich enough to support objects, classes, arrays
  \begin{itemize}
    \item local variables (including method parameters)
    \item static fields
    \item object fields
    \item array elements
  \end{itemize}

  Ensured by allowing proper terms in formulas.

\end{itemize}

\section*{Predicate language}

\begin{grammar}
<predicate> ::= `not' `(' <predicate> `)'
    \alt `(' <predicate> `and' <predicate> `)'
    \alt `(' <predicate> `or'  <predicate> `)'
    \alt `true'
    \alt `false'
    \alt <expression> `=' <expression>
    \alt <expression> `\textless' <expression>

<expression> ::= <term>
    \alt <term> `+' <term>
    \alt <term> `-' <term>

<term> ::= <factor>
    \alt <factor> `*' <factor>
    \alt <factor> `/' <factor>

<factor> ::= "constant"
    \alt <path>
    \alt <altpath>
    \alt `(' <expression> `)'

<path> ::= <path> `.' "fieldname"
    \alt <path> `[' "index" `]'
    \alt "classname" `.' "staticfieldname"
    \alt "varname"

<altpath> ::= `field' `(' <altpath> `,' "fieldname" `)'
    \alt `array' `(' <altpath> `,' "index" `)'
    \alt `field' `(' "classname" `,' "staticfieldname" `)'
    \alt "varname"
\end{grammar}

The dot-notation (\ap{a}{b}{f}) is a syntactic sugar for the notation based on function calls. All expressions with dots will be translated into the function-notation internally.

\subsection*{Identifiers - Variable/Field/Class names}

The root element of an access path is always an identifier of an instance (local or static). 
If some element of the access path is a variable of a reference type, then its value uniquely identifies the object (by its heap address (objRef)).
Field names and array indices follow.
Every path ends in a primitive-typed field / element (or its wrapper: Integer, Double, Float \ldots ?) otherwise the whole expression does not make sense.

We will also consider the scope of variables. If some predicate contains an expression \ap{a}{}{f}, where \var{a} is a local variable of some method {\it m}, then the predicate is defined only in the scope of the method {\it m}.


\subsection*{SMT-LIB Lisp-like syntax}

Not very effective from manual-maintenance point of view.

\section*{Extension to JPF Abstraction}

\begin{itemize}
\item {\bf Abstract value} $\sim$ valuation of individual predicates
\item Predicates evaluate to $\left\{ \begin{array}{lcl}\text{\tt undefined} &\sim& \text{\it referring to out-of-scope variables} \\ \text{\tt 0} &\sim& \text{\tt false} \\ \text{\tt 1} &\sim& \text{\tt true} \\ \text{\tt unknown (*)} &\sim& \text{\tt TOP} \end{array} \right. $

\begin{figure}[!h]
\centering
\includegraphics{figure0}
\end{figure}

\FloatBarrier

\item Concrete value kept unmodified for SMT purposes

\item {\bf Global abstraction} - There is a single valuation of all input predicates shared between all the abstract values (attributes to all the concrete values)

  \begin{itemize}
  \item {\bf Benefits}
    \begin{itemize}
    \item Avoids redundancy (No need to have two truth value estimates for a single predicate stored in two different abstract values)
    \item Implies consistency (No differences)
    \item Provides accessibility to the most extensive information for all the abstract values
    \end{itemize}

  \item {\bf Requirements}
    \begin{itemize}
    \item Maintenance (backtracking, instruction execution \ldots)
    \item Serialisation (state matching)
    \end{itemize}

  \item {\bf Update}
    \begin{itemize}
    \item Invoked by change of scope
    \item Invoked by instruction execution

    Predicate determines what access paths it depends on.
    Only predicates depending on paths affected by a given instruction are updated.
    Unaffected predicates keep their value.
    This may save a considerable number of SMT invocations.

    \newpage
    The following example demonstrates challenges that severely affect the design of our solution.

    \begin{lstlisting}
    public void m(ClassX a) {
      ClassY b = a.y;
      ...
      ... a.y.z.field + b.z.field ...
      ...
    }
    \end{lstlisting}

    \begin{figure}[!h]
    \centering
    \includegraphics{figure1}
    \end{figure}

    \FloatBarrier

    \begin{figure}[!h]
    \centering
    \includegraphics{figure2}
    \end{figure}

    \FloatBarrier

    Resolve all paths used in a concrete predicate:
    \begin{itemize}
    \item defined $\Rightarrow$ add clause $\text{\tt path} = value$
    \item undefined $\Rightarrow$ predicate undefined
    \end{itemize}

    \begin{algorithm}
    \begin{algorithmic}
    \Procedure{updatePredicates}{$Predicates, Valuation, AffectedPaths$}
    \ForAll{$p \in Predicates$}
      \If{$AffectedPaths \cap usedPaths(p) \neq \emptyset$}
        \State $Valuation \gets Valuation \oplus p \mapsto evalPredicate(p)$
      \EndIf
    \EndFor
    \EndProcedure
    \end{algorithmic}
    \end{algorithm}

    \begin{algorithm}
    \begin{algorithmic}
    \Function{evalPredicate}{$P$}
    \State $Q \gets P$
    \ForAll{$p \in usedPaths(P)$}
      \State $e \gets pathToElementInfo(p)$
      \State $v \gets getValue(e)$
      \State $Q \gets Q \wedge p = v$
    \EndFor
    \Return $SMT(Q)$
    \EndFunction
    \end{algorithmic}
    \end{algorithm}

    \FloatBarrier


  \end{itemize}
\end{itemize}

\item Implementation mechanisms

  \begin{itemize}
  \item Bytecode instructions
  \item Serialisation
  \item Attribute system
  \item \ldots
  \item AbstractValue (if not proven to have unsuitable interface)
  \item AbstractInstructionFactory (co-existence with other abstractions)
  \item Scope-aware Map: $path \mapsto \text{primitive \tt ElementInfo e}$
  \item Scope-aware Map: $\text{primitive \tt ElementInfo e} \mapsto \left\{p\:\middle\vert\:p\:\text{access path to \tt e}\right\}$
  \end{itemize}

\item Mapping variables / class names to concrete ElementInfo / ClassInfo objects in concrete scope.

Needed to be able to provide SMT with fixed values of referred variables.
The mapping needs to allow looking up corresponding ElementInfo's for a given access path (To allow use of concrete values in predicates to capture current state) but also for a given ElementInfo all possible currently valid access paths (To allow filtering out affected predicates for re-evaluation).

  Choose one of:
  \begin{itemize}
  \item provide a dictionary of our own

    {\bf Pros:}
    \begin{itemize}
    \item Fast (Hash tables or other dictionary-like structures instead of arrays)
    \end{itemize}

    {\bf Cons:}
    \begin{itemize}
    \item Need to handle backtracking and scoping in general
    \end{itemize}
  \item extract needed information from ThreadInfo, StackFrame and VM
    \begin{itemize}
    \item {\bf Fields:} ThreadInfo.getElementInfo, StackFrame.getThis, ElementInfo.getClassInfo, ClassInfo.getInstanceField
    \item {\bf Locals:} StackFrame.getLocalVars
    \item {\bf Static:} VM.getClassLoaderList, ClassLoaderInfo.loadedClasses, ClassInfo.getStatics \ldots
    \end{itemize}

    {\bf Pros:}
    \begin{itemize}
    \item Existing code
    \item State maintained over backtracking / \ldots
    \end{itemize}

    {\bf Cons:}
    \begin{itemize}
    \item One-way (Path to ElementInfo)
    \item {\it Need of debugging symbols}
    \end{itemize}
    
  \end{itemize}

\item SMT - invoked as a separate process

Use:
\begin{itemize}
\item at update of the abstract value
\item at branch choice
\end{itemize}

Choices:
\begin{itemize}
\item {\bf MathSAT 5} - accepts SMT-LIB format and DIMACS format
\item Yices
\item \ldots
\end{itemize}

\end{itemize}

\end{document}
