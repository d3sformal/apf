\documentclass{article}

\usepackage{graphics}
\usepackage{listings}
\usepackage[cm]{fullpage}
\usepackage{syntax}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{placeins}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{ulem}
\usepackage{multirow}

\lstset{language=Java}

% Variable
\def\var#1{{\tt \bf #1}}

% Access path
\def\ap#1#2#3{%
{\tt \var{#1}.%
\edef\p{#2}%
\edef\e{}%
\ifx\p\e%
\else%
#2.%
\fi%
#3}%
}

% code (inline)
\def\code#1{
{\tt #1}
} 


\begin{document}

\title{Predicate Abstraction in JPF}

\maketitle

The main goal is to support important features of Java (objects, classes, fields, arrays, local variables) and predicates over variables that have numerical data types.
We consider primitive types (byte, short, char, int, long, float, double) and also wrapper classes (Integer, Double, etc).
The level of support for floating-point numbers depends on the abilities of SMT solvers.

\section*{Predicate language}

The predicate language must be rich enough to support the following: classes, objects, static fields, instance fields, local variables (including method parameters), arrays, and array elements.
Syntax of the predicates is captured by this grammar:

\begin{grammar}
<predicate> ::= `not' `(' <predicate> `)'
    \alt `true'
    \alt `false'
    \alt <expression> `=' <expression>
    \alt <expression> `\textless' <expression>

<expression> ::= <term>
    \alt <term> `+' <term>
    \alt <term> `-' <term>

<term> ::= <factor>
    \alt <factor> `*' <factor>
    \alt <factor> `/' <factor>

<factor> ::= "constant"
    \alt <dotpath>
    \alt <funpath>
    \alt `(' <expression> `)'

<dotpath> ::= <dotpath> `.' "fieldname"
    \alt <dotpath> `[' <expression> `]'
    \alt "classname" `.' "fieldname"
    \alt "varname"

<funpath> ::= `fread' `(' "fieldname" `,' <funpath> `)'
    \alt `aread' `(' `arr', `,' <funpath> `,' <expression> `)'
    \alt `alength' `(' `arr', `,' <funpath> `)'
    \alt `fread' `(' "fieldname" `,' "classname" `)'
    \alt "varname"
\end{grammar}

The dot-notation (\ap{a}{b}{f}) is a syntactic sugar for the internal notation based on functions (fread, aread).
All expressions with dots will be translated into the functions-based notation internally.

The special function \code{alength} represents the length of a given array.

The grammar does not include logic operators (and, or) and quantifiers, because we do not care much about properties here.
Formulas that represent properties over arrays typically involve quantifiers.

\subsection*{Identifiers}

The first element (root) of an access path must be a local variable name (including \code{this}) or a class name. The root is followed by zero or more field names.
If some element of an access path is a variable or field of a reference type, then its value uniquely identifies the respective object by its heap address (objRef).
The last element of a full access path must be an expression (local variable, field, array element) of a numeric type (primitive, wrapper class), otherwise the whole expression does not make sense for us.
We also support prefixes of access paths that refer to heap objects.

We must also consider the scope of local variables. 
If some predicate contains an expression \ap{a}{}{f}, where \var{a} is a local variable of some method {\it m}, then the predicate is defined only in the scope of the method {\it m}.

One predicate can refer to fields of different objects. 
Example: \ap{this}{o1}{f} \textless \ \ap{p1}{}{g}, where \var{p1} is a method parameter (an object different from \ap{this}{}{o1}).

If a given predicate refers only to object fields (not local variables of some method), such as \ap{this}{}{f1} \textless \ \ap{this}{}{f2}, then it will be defined during method calls on the given object.

\subsection*{Multiple Instances}

We support predicates over multiple instances (dynamically created) of a given class.
For example, the predicate \ap{this}{}{a} \textless \ \ap{this}{}{b} defined for a specific class is evaluated during each method call on every object of the given class. 
In some sense, it is a predicate over fields of all existing instances (dynamically created) of the given class.

Regarding allocation of many objects in a loop, e.g. as in the following code,
\begin{lstlisting}
  for (int i = 0; i < size; i++) {
    a[i] = new Data();
  }
\end{lstlisting}
we support predicates like \ap{a[i]}{}{f} \textless \ \ap{a[i-1]}{}{f}, which also cover multiple instances in a certain sense.

\section*{Abstract State}

An \textit{abstract state} is the valuation (truth values) of all individual predicates defined in the current context (scope).
Each predicate must be associated with some class (for predicates that refer only to fields and numeric constants) or with some method (for predicates that refer also to local variables).

\vspace{\baselineskip}

Each predicate evaluates to $\left\{ \begin{array}{lcl}\text{\tt undefined} &\sim& \text{\it referring to out-of-scope variables} \\ \text{\tt 0} &\sim& \text{\tt false} \\ \text{\tt 1} &\sim& \text{\tt true} \\ \text{\tt unknown (*)} &\sim& \text{\tt TOP} \end{array} \right.$

\begin{figure}[!h]
  \centering
  \includegraphics{figure0}
\end{figure}

In each state, we will store valuations of all predicates defined in the current scope. 
We may preserve the concrete values of some variables too (i.e., not setting them to 0 like in the original Abstract Pathfinder), because they may be useful in deciding values of certain predicates with the SMT solver (see below).
However, this would negatively impact the benefits of abstraction (reduced state space). We can let the user decide (make this configurable).

The initial value of each predicate is \texttt{undef} (\texttt{unknown}). When a new heap object is allocated, all predicates over its fields will have the value \texttt{unknown}.

We will use a {\bf single global container} for current values of all predicates. Values will not be stored in attributes for objects, fields, and local variables (stack frame slots).
The container is a map from predicates to their values.
This approach has several benefits:
\begin{itemize}
	\item avoiding redundancy (no need to store values at two different locations if the given predicate refers to two local variables or instance fields),
	\item consistency (when the predicate value is stored at one place), and
	\item easy access to current values for all predicates (over all objects).
\end{itemize}

This container must be properly managed during the state space traversal --- restored to a previous value when JPF backtracks, and so on.

\vspace{\baselineskip}
 
For each value on the current stack frame (context, scope) that represents an object reference, we must know the access path through which the value was acquired, so that we can find the corresponding predicates.
The access path can be a local variable name, or a local variable name followed by a sequence of field names.
We will keep the access path for a given value on the stack in its attribute.
If we have the value $v$ on the top of the stack frame and its access path \ap{this}{}{f} in the attribute for $v$, and JPF executes a getfield instruction on $v$ and the field \code{g}, the new value on the top of the stack frame will be $w$ and its access path will be \ap{this}{f}{g} --- then we know that a predicate referring to \ap{this}{f}{g} applies to $w$.
For local variables, we can find their names via methods of the \code{StackFrame} class if the debugging symbols are available (loaded from the class file).

\subsection*{Updating}

Truth values of some predicates are updated either when the current scope changes (call, return) or when JPF executes some data-manipulation instruction (putfield, istore, etc).
We process numerical operations (addition, etc) and load instructions using symbolic execution and update truth values of predicates only at assignment statements and method call boundaries.
For each instruction we must update (process) only the predicates affected by the instruction. We identify the affected predicates using the access paths for the instruction operands.
Original value is preserved for other (unaffected) predicates.
This may save a considerable number of calls to the SMT solver.

When the name of a local variable is not available for some reason (e.g., the class file does not contain debugging information), then we must update all predicates over local variables of the given method.
One option would be to take all predicates that refer to some local variable of the given method (they are all relevant in that case).

In the case of bytecode instructions that read or modify some array element, the set of relevant predicates contains all predicates that refer to the respective array variable and to variables aliased with it. 
This means especially predicates over the given array that do not use constant indexes.

Note that two methods can have a local variable with the same name. When processing a predicate that refers to this variable name, we must use the association of the predicate with a particular method to find the right scope for the predicate, i.e. to determine whether it is a relevat predicate for the current instruction (method).

However, there are still difficult challenges.
The following example demonstrates the case when we have two different access paths leading to the same object.
The field \code{f} of a given object of the class \code{ClassZ} is accessible through \ap{a}{y.z}{f} and \ap{b}{z}{f}.
If JPF executes an instruction that uses \ap{a}{y.z}{f}, then we must update truth value of predicates over \ap{a}{y.z}{f} and also predicates over \ap{b}{z}{f}.

\begin{lstlisting}
  public void m(ClassX a) {
    ClassY b = a.y;
    ... 
    a.y.z.f = 5;
    ...
    b.z.f = x + 1;
    ...
  }
\end{lstlisting}

\begin{figure}[!h]
  \centering
  \includegraphics{figure1}
\end{figure}

\FloatBarrier

We use a map from access paths to sets of value IDs. A value ID represents a primitive value of a numeric type or a heap object (reference).
Each access path can refer to a single object or primitive value, when we have a precise information, or it can refer to a set of objects (when we do not know precisely).
This is like when a static pointer analysis finds a set of possible target objects (a points-to set) for each variable (access path) --- a set of objects that the variable can refer to at some point.
An access path can be complete up to a local variable or an object field of a numeric data type (a predicate can refer to such an access path), or the access path can be only partial (prefix refering to a heap object).
We also need a map from value IDs (object references (ElementInfo), numeric values) to sets of access paths. For a given value ID, the map specifies the set of all access paths that may possibly refer to a given value (object) in the given scope (call context).
Using these maps we can find aliased access paths and then predicates which must be updated when executing a particular instruction.

To correctly process an assignment statement \code{v := e}, where \code{v} is an access path (local variable, object field), it is necessary to find all affected access paths (that means \code{v} and all paths that may point to the same object as \code{v}) and update the mapping for all the access paths.
The mappings have to be updated for the whole subtree of \code{v} (all access paths with the prefix \code{v}) on the basis of the whole subtree of \code{e} --- this is important for assignment to an object field, e.g. \code{p.f := o}, when the access paths such as \ap{p}{f.g}{h} and \ap{o}{g}{h} exist.

We can find the set of affected access paths in this way: (1) we get the value IDs pointed to by \code{v} from one map and then (2) for each value ID we get all access paths that can refer to it from the second map.
In case of the statement \code{a[i] = e}, the possibly affected access paths are all elements of the array (\code{a[0]***, ..., a[n]***}), because we do not know the precise value of \code{i} --- we do not know precisely which element of the array was modified with the new value, if \code{i} is an arbitrary expression.

A special case are call and return instructions. 
When executing a call to the method $m$, truth values of predicates over \code{this} and formal parameters of $m$ must be set according to truth values of predicates over the actual parameters for the call. 
When executing a return instruction, truth values of predicates over the parameters of reference types and the returned value must be propagated to the caller.
Truth value of predicates that refer only to fields of some object (via \code{this}) must be preserved between different method calls on the object, i.e. the value at the entry to some call on the object must be the same as the value at the exit from a previous call on the object (assuming that variables and fields referred to by the predicate were not explicitly modified between the calls).

New values of predicates are computed with the help of an SMT solver. We use the standard approach based on weakest preconditions for assignment statements $v = e$, where $v$ can be any program variable (local variable, object field, array element) and $e$ can be any arithmetic expression.
We use logic formulas $\bigwedge \nu(D) \Rightarrow \mathit{WP}(s,p)$, where $\nu(D)$ represents truth values of relevant predicates in the current dynamic program state, as input for the SMT solver.
The set $D$ (determining predicates) contains all predicates that are in the current scope (context), i.e. predicates defined for the current method and for the type (class) of the receiver object ("\code{this}").
We do not have to filter predicates based on access paths (sharing with $p$), because we make just two calls of the SMT solver for each assignment --- one for $\mathit{WP}(p)$ and the second for $\mathit{WP}(\lnot p)$ --- and not $2^N$ calls of the SMT solver where $N$ is the number of determining predicates.
The following table shows weakest preconditions for assignment statements. The symbol $F_x$ denotes any valid atomic predicate over the expression $x$ that is not covered by other lines of the table for a given statement.
Weakest preconditions capture aliasing --- e.g., truth value of the weakest precondition for the statement \code{o.f = e} and the predicate $\mathit{fread}(f,o') \ \mathrm{relop} \ u$ depends on whether $o = o'$.

\begin{table*}[!h]
\centering
\begin{tabular}{|l|l|l|}
\hline
\multicolumn{1}{|c|}{ Statement $s$ } & \multicolumn{1}{|c|}{ Predicate $p$ } & \multicolumn{1}{|c|}{ $WP(s,p)$ } \\ 
\hline

\multirow{1}*{ \code{w = w'} } 
 & $ F_w $ & $ p[w'/w] $ \\

\hline

\multirow{1}*{ \code{w = e} } 
 & $ w \ \mathrm{relop} \ u $ & $ e \ \mathrm{relop} \ u $ \\

\hline

\multirow{1}*{ \code{o.f = e} } 
 & $ \mathit{fread}(f,o') \ \mathrm{relop} \ u $ & $ \mathit{fread}(\mathit{fwrite}(f,o,e),o') \ \mathrm{relop} \ u $ \\

\hline

\multirow{2}*{ \code{o = new C} }
 & $ o = w $ & $ \mathrm{false} $ \\
\cline{2-3}
 & $ \mathit{fread}(f,o) \ \mathrm{relop} \ u $ & $ \mathrm{false} $ \\

\hline

\multirow{2}*{ \code{a[i] = e} }
 & $ \mathit{aread}(\mathrm{arr},a',i') \ \mathrm{relop} \ u $ & $ \mathit{aread}(\mathit{awrite}(\mathrm{arr},a,i,e),a',i') \ \mathrm{relop} \ u $ \\
\cline{2-3}
 & $ \mathit{aread}(\mathrm{arr},b,\mathit{aread}(\mathrm{arr},a',i')) \ \mathrm{relop} \ u $ & $ \mathit{aread}(\mathit{awrite}(\mathrm{arr},a,i,e),b,\mathit{aread}(\mathit{awrite}(\mathrm{arr},a,i,e),a',i')) \ \mathrm{relop} \ u $ \\

\hline
\end{tabular}
\end{table*}

\FloatBarrier

If some relevant predicate has the value \texttt{unknown} in the current dynamic program state, then we add \texttt{true} (i.e., nothing) into the sub-formula $\bigwedge \nu(D)$.

The following algorithm summarizes the procedure for computing new values of relevant predicates at some instruction.
The set $\text{AffectedPaths}$ contains all access paths affected by the given instruction, and the function expression $paths(p)$ returns all access paths referred to by the predicate $p$.
The procedure $\text{evalPredicates}$ calls the SMT solver.

\begin{algorithm}
\begin{algorithmic}
  \Procedure{updatePredicates}{$\text{Instruction}, \text{Predicates}, \text{Valuation}, \text{AffectedPaths}$}
    \State $RelevantPredicates \gets \emptyset$
    \ForAll{$p \in Predicates$}
      \If{$AffectedPaths \cap paths(p) \neq \emptyset$}
        \State $RelevantPredicates \gets RelevantPredicates \cup p$
      \EndIf
    \EndFor
    \ForAll{$p \in RelevantPredicates$}
      \State $Valuation \gets evalPredicates(\text{Instruction}, \text{RelevantPredicates}, \text{Valuation})$
    \EndFor
  \EndProcedure
\end{algorithmic}
\end{algorithm}

\FloatBarrier

We could also use information from the dynamic state. 
If the given predicate refers to an access path $ap$, then we could find a concrete value of the path $ap$ in the dynamic program state and use the concrete value in the logic formula (input for SMT) as another constraint (clause) of the form $ap = \text{value}$.
For example, given the predicate \code{a[i]} \textgreater \code{x} and the concrete value for \code{a[i]} being 5, we can add the constraint $\text{aread}(\text{arr},a,i) = 5$.

This figure illustrates all the steps that must be performed for each instruction.

\begin{figure}[!h]
  \centering
  \includegraphics{figure2}
\end{figure}

\FloatBarrier

\section*{Abstract state space}

Predicate abstraction causes non-deterministic choices to be created only at branching instructions (if, switch). 
If the condition evaluates to \code{unknown} at some instruction, a new choice generator is created such that all branches can be explored subsequently.
We do not make choices at assignment statements for predicates that get the value \code{unknown}, but leave this up to the branching instruction that depends on the predicate value.

\section*{Implementation}

We will use the following mechanisms of JPF:
\begin{itemize}
  \item Custom bytecode interpreter
  \item Serialization
  \item Attribute system
\end{itemize}

We also plan to use some code from the original Abstract Pathfinder. 
For example, the classes \code{AbstractValue} (if it has a suitable interface) and \code{AbstractInstructionFactory}.
We should allow mixing (co-existence) of predicate abstraction with numeric abstractions (signs, etc).

The following API methods can provide necessary information about variables:
\begin{itemize}
  \item {\bf fields:} ThreadInfo.getElementInfo, StackFrame.getThis, ElementInfo.getClassInfo, ClassInfo.getInstanceField
  \item {\bf locals:} StackFrame.getLocalVars
  \item {\bf static:} VM.getClassLoaderList, ClassLoaderInfo.getStatics
\end{itemize}

We will probably run the SMT solver in a separate process (not via a Java binding).
How to use it: prepare input (command-line, string), execute the system process, and parse output ("sat", "unsat").
Options: {\bf MathSAT 5} (the preferred one), Yices, CVC4, \ldots.

The input to each call of the SMT solver contains also auxiliary clauses, which express the semantics of Java.
For example, the clause $\mathit{alength}(arr,a) \ge 0$ for each variable $a$ of an array type.

Symbolic execution of numerical operations and load instructions (\code{getfield}, \code{iload}) works with a symbolic stack.
For example, when processing the bytecode instruction \code{iadd} and input symbolic values $x$ and $1$ on the symbolic stack, we get a symbolic expression $x+1$ and put it on the symbolic stack.

\section*{State Matching over Predicates}

For two states $s_1$ and $s_2$, where $s_1$ has been already visited before and $s_2$ is the currently processed state, we must determine whether $s_2$ is already covered by $s_1$ ($s_1 \sim s_2$, subsumption), i.e. we must decide whether to consider $s_2$ as already visited too.
One option is to create formulas based on truth values of predicates and ask the SMT solver.
We assume that $PC(s_1) = PC(s_2)$ because otherwise $s_1 \not \sim s_2$.

Our plan is to check related work, especially abstract state matching with subsumption for symbolic execution.

We must also modify the serializer. It will preserve the concrete values (for selected variables) or save 0 (otherwise), but we have to decide what to do with predicates during serialization.

Variables captured in the predicates cannot be serialized normally. One option might be to save the boolean vector containing truth values of all relevant predicates.

\section*{Usage / Running}

Input: a set of predicates defined in a textual file. The name of the file (path) will be passed to the abstraction module through a {\tt .jpf} file.
The user must define predicates over local variables of each method separately, predicates over instance fields of each class, and predicates over static fields (of all classes together).

We impose certain restrictions on the input bytecode (Java source code).
We do not support assignment statements which include store of some value into some variable (e.g., operations such as \code{++a} and \code{a = 1000}) on the right hand side.
The result of the right hand side must be a value without any side effects, which is then stored into the variable (access path) specified at the left hand side of the assignment statement.
Example number 1: statement \code{b = (a + 4) + (++a)} must be replaced with a sequence \code{t1 = a + 4; a = a + 1; b = t1 + a}.
Example number 2: statement \code{b = (a + 4) + (a = 1000)} must be replaced with \code{t1 = a + 4; a = 1000; b = t1 + a}.
There must be predicates over temporary variables --- for example, $a = 0$, $t1 = 4$, $t1 > 0$, $a = 1$, $b > 4$, etc (manually defined).

\end{document}

