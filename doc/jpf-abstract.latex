\documentclass{article}

\usepackage{graphics}
\usepackage{listings}
\usepackage[cm]{fullpage}
\usepackage{syntax}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{placeins}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{ulem}

\lstset{language=Java}

% Variable
\def\var#1{{\tt \bf #1}}

% Access path
\def\ap#1#2#3{%
{\tt \var{#1}.%
\edef\p{#2}%
\edef\e{}%
\ifx\p\e%
\else%
#2.%
\fi%
{\it #3}}%
}


\begin{document}

\title{Predicate Abstraction in JPF}

\maketitle

The main goal is to support important features of Java (objects, classes, fields, arrays, local variables) and predicates over variables that have numerical data types.
We consider primitive types (byte, short, char, int, long, float, double) and also wrapper classes (Integer, Double, etc).

\section*{Predicate language}

The predicate language must be rich enough to support the following: classes, objects, static fields, instance fields, local variables (including method parameters), arrays, and array elements.
Syntax of the predicates is captured by this grammar:

\begin{grammar}
<predicate> ::= `not' `(' <predicate> `)'
    \alt `true'
    \alt `false'
    \alt <expression> `=' <expression>
    \alt <expression> `\textless' <expression>

<expression> ::= <term>
    \alt <term> `+' <term>
    \alt <term> `-' <term>

<term> ::= <factor>
    \alt <factor> `*' <factor>
    \alt <factor> `/' <factor>

<factor> ::= "constant"
    \alt <dotpath>
    \alt <funpath>
    \alt `(' <expression> `)'

<dotpath> ::= <dotpath> `.' "fieldname"
    \alt <dotpath> `[' <expression> `]'
    \alt "classname" `.' "fieldname"
    \alt "varname"

<funpath> ::= `fread' `(' "fieldname" `,' <funpath> `)'
    \alt `aread' `(' `arr', `,' <funpath> `,' <expression> `)'
    \alt `fread' `(' "fieldname" `,' "classname" `)'
    \alt "varname"
\end{grammar}

The dot-notation (\ap{a}{b}{f}) is a syntactic sugar for the internal notation based on functions (fread, aread).
All expressions with dots will be translated into the functions-based notation internally.

The grammar does not include logic operators (and, or) and quantifiers, because we do not care much about properties here.
Formulas that represent properties over arrays typically involve quantifiers.


\subsection*{Identifiers}

The first element (root) of an access path is a local variable name (including \texttt{this}) or a class name.
If some element of an access path is a variable or field of a reference type, then its value uniquely identifies the respective object by its heap address (objRef).
The last element of an access path must be an expression (local variable, field, array element) of a numeric type (primitive, wrapper class), otherwise the whole expression does not make sense for us.

We must also consider the scope of local variables. 
If some predicate contains an expression \ap{a}{}{f}, where \var{a} is a local variable of some method {\it m}, then the predicate is defined only in the scope of the method {\it m}.

One predicate can refer to fields of different objects. 
Example: \texttt{this}.o1.f \textless \ p1.g, where p1 is a method parameter (an object different from \texttt{this}.o1).








% TODO

\section*{Usage / Running}

Input: a set of predicates defined in a textual file whose name (path) is passed as an argument to the selected predicate abstraction in a .jpf file.


\section*{Abstract State}

\begin{itemize}
\item {\bf Abstract value} $\sim$ valuation of individual predicates
\item Predicates evaluate to $\left\{ \begin{array}{lcl}\text{\tt undefined} &\sim& \text{\it referring to out-of-scope variables} \\ \text{\tt 0} &\sim& \text{\tt false} \\ \text{\tt 1} &\sim& \text{\tt true} \\ \text{\tt unknown (*)} &\sim& \text{\tt TOP} \end{array} \right. $

  \begin{figure}[!h]
  \centering
  \includegraphics{figure0}
  \end{figure}

  \FloatBarrier

\item Concrete value kept unmodified for SMT purposes
\item {\bf Global abstraction} - There is a single valuation of all input predicates shared between all the abstract values (attributes to all the concrete values)
  \begin{figure}[!h]
  \centering
  \includegraphics{figure3}
  \end{figure}

  \FloatBarrier

  \begin{itemize}
  \item {\bf Benefits}
    \begin{itemize}
    \item Avoids redundancy (No need to have two truth value estimates for a single predicate stored in two different abstract values)
    \item Implies consistency (No differences)
    \item Provides accessibility to the most extensive information for all the abstract values
    \end{itemize}

  \item {\bf Requirements}
    \begin{itemize}
    \item Maintenance (backtracking, instruction execution \ldots)
    \item Serialisation (state matching)
    \end{itemize}

  \item {\bf Update}
    \begin{itemize}
    \item Invoked by change of scope
    \item Invoked by instruction execution

    Predicate determines what access paths it depends on.
    Only predicates depending on paths affected by a given instruction are updated.
    Unaffected predicates keep their value.
    This may save a considerable number of SMT invocations. \\

    The following example demonstrates challenges that severely affect the design of our solution.

    \begin{lstlisting}
    public void m(ClassX a) {
      ClassY b = a.y;
      ... a.y.z.field + b.z.field ...
    }
    \end{lstlisting}

    \begin{figure}[!h]
    \centering
    \includegraphics{figure1}
    \end{figure}

    \FloatBarrier

    \begin{figure}[!h]
    \centering
    \includegraphics{figure2}
    \end{figure}

    \FloatBarrier

    \newpage
    Resolve all paths used in a concrete predicate:
    \begin{itemize}
    \item defined $\Rightarrow$ add clause $\text{\tt path} = value$
    \item undefined $\Rightarrow$ predicate undefined
    \end{itemize}

    \begin{algorithm}
    \begin{algorithmic}
    \Procedure{updatePredicates}{$Predicates, Valuation, AffectedPaths$}
    \ForAll{$p \in Predicates$}
      \If{$AffectedPaths \cap usedPaths(p) \neq \emptyset$}
        \State $Valuation \gets Valuation \oplus p \mapsto evalPredicate(p)$
      \EndIf
    \EndFor
    \EndProcedure
    \end{algorithmic}
    \end{algorithm}

    \begin{algorithm}
    \begin{algorithmic}
    \Function{evalPredicate}{$P$}
    \State $Q \gets P$
    \ForAll{$p \in usedPaths(P)$}
      \State $e \gets pathToElementInfo(p)$
      \State $v \gets getValue(e)$
      \State $Q \gets Q \wedge p = v$
    \EndFor
    \Return $SMT(Q)$
    \EndFunction
    \end{algorithmic}
    \end{algorithm}

    \FloatBarrier


  \end{itemize}
\end{itemize}

\section*{Implementation: Extension to JPF Abstraction}

\item Implementation mechanisms

  \begin{itemize}
  \item Bytecode instructions
  \item Serialisation
  \item Attribute system
  \item \ldots
  \item AbstractValue (if not proven to have unsuitable interface)
  \item AbstractInstructionFactory (co-existence with other abstractions)
  \item Scope-aware Map: access path $p$ to {\tt e} $\mapsto$ primitive {\tt ElementInfo e}
  \item Scope-aware Map: $\text{primitive \tt ElementInfo e} \mapsto \left\{p\:\middle\vert\:p\:\text{access path to \tt e}\right\}$
  \end{itemize}

\item Mapping variables / class names to concrete ElementInfo / ClassInfo objects in concrete scope.

Needed to be able to provide SMT with fixed values of referred variables.
The mapping needs to allow looking up corresponding ElementInfo's for a given access path (To allow use of concrete values in predicates to capture current state) but also for a given ElementInfo all possible currently valid access paths (To allow filtering out affected predicates for re-evaluation).

  Choose one of:
  \begin{itemize}
  \item provide a dictionary of our own

    {\bf Pros:}
    \begin{itemize}
    \item Fast (Hash tables or other dictionary-like structures instead of arrays)
    \end{itemize}

    {\bf Cons:}
    \begin{itemize}
    \item Need to handle backtracking and scoping in general
    \end{itemize}
  \item extract needed information from ThreadInfo, StackFrame and VM
    \begin{itemize}
    \item {\bf Fields:} ThreadInfo.getElementInfo, StackFrame.getThis, ElementInfo.getClassInfo, ClassInfo.getInstanceField
    \item {\bf Locals:} StackFrame.getLocalVars
    \item {\bf Static:} VM.getClassLoaderList, ClassLoaderInfo.loadedClasses, ClassInfo.getStatics \ldots
    \end{itemize}

    {\bf Pros:}
    \begin{itemize}
    \item Existing code
    \item State maintained over backtracking / \ldots
    \end{itemize}

    {\bf Cons:}
    \begin{itemize}
    \item One-way (Path to ElementInfo)
    \item {\it Need of debugging symbols ???}
    \end{itemize}
    
  \end{itemize}

\item SMT - invoked as a separate process

Use:
\begin{itemize}
\item at update of the abstract value
\item at branch choice
\item state matching over predicates

  $s_1, s_2$ states, $s_1$ already visited, $s_2$ current. Determine whether $s_1 \sim s_2$ (Subsumption). \\

  Test whether $s_2$ is already visited based on truth values of the predicates. 
  One option is to create formulas and use SMT to decide.

  Assume $PC(s_1) = PC(s_2)$ otherwise $s_1 \not \sim s_2$.

  We will check related work, especially abstract state matching with subsumption for symbolic execution.

%  Example: \\
%
%  $s_1$:
%  \begin{itemize}
%  \item $P_1$
%  \item $\neg P_2$
%  \item $P_3$
%  \item $P_4$ unknown
%  \end{itemize}
%
%  $s_2$:
%  \begin{itemize}
%  \item $P_1$
%  \item $\neg P_2$
%  \item $P_3$ undefined
%  \item $P_4$
%  \end{itemize}

%  SMT: $s_1 \Rightarrow sdd_2$ ?\\

%  If $s_2$ is a consequence of $s_1$ which we have already visited then it is impossible to infer anything new (branching etc.).
%  The new state is therefore effectively equivalent.
\end{itemize}

Choices:
\begin{itemize}
\item {\bf MathSAT 5} - accepts SMT-LIB format and DIMACS format
\item Yices
\item \ldots
\end{itemize}

\end{itemize}

\end{document}
