\documentclass{article}

\usepackage{graphics}
\usepackage{listings}
\usepackage[cm]{fullpage}
\usepackage{syntax}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{placeins}

\lstset{language=Java}

\begin{document}

\section*{JPF Predicate Abstraction}

\begin{itemize}

\item Predicates defined per program

Defined in a textual file whose name (path) is passed as an argument to the selected predicate abstraction in a .jpf file.

\item Focus solely on numerical data types (byte, char, short, int, long, float, double)
\item Predicate language rich enough to support objects, classes, arrays
  \begin{itemize}
    \item local variables (including method parameters)
    \item static fields
    \item object fields
    \item array elements
  \end{itemize}

  Ensured by allowing proper terms in formulas.

\end{itemize}

\section*{Predicate language}

\begin{grammar}
<predicate> ::= `not' `(' <predicate> `)'
    \alt `(' <predicate> `and' <predicate> `)'
    \alt `(' <predicate> `or'  <predicate> `)'
    \alt `true'
    \alt `false'
    \alt <term> `=' <term>
    \alt <term> `\textless' <term>

<term> ::= "constant"
    \alt <path>
    \alt <altpath>

<path> ::= <path> `.' "fieldname"
    \alt <path> `[' "index" `]'
    \alt "classname" `.' "staticfieldname"
    \alt "varname"

<altpath> ::= `field' `(' <altpath> `,' "fieldname" `)'
    \alt `array' `(' <altpath> `,' "index" `)'
    \alt `field' `(' "classname" `,' "staticfieldname" `)'
    \alt "varname"
\end{grammar}

\subsection*{Identifiers - Variable/Field/Class names}

The root element of a path is always an identifier of an instance (local or static).
Field names and array indices follow.
Every path ends in a primitive-typed field / element (or its wrapper: Integer, Double, Float \ldots ?) otherwise the whole expression does not make sense.

\subsection*{SMT-LIB Lisp-like syntax}

Not very effective from manual-maintenance point of view.

\section*{Extension to JPF Abstraction}

\begin{itemize}
\item {\bf Abstract value} $\sim$ valuation of individual predicates
\item {\bf Global abstraction} - There is a single valuation of all input predicates shared between all the abstract values (attributes to all the concrete values)

  \begin{itemize}
  \item {\bf Benefits}
    \begin{itemize}
    \item Avoids redundancy (No need to have two truth value estimates for a single predicate stored in two different abstract values)
    \item Implies consistency (No differences)
    \item Provides accessibility to the most extensive information for all the abstract values
    \end{itemize}

  \item {\bf Requirements}
    \begin{itemize}
    \item Maintenance (backtracking, instruction execution \ldots)
    \item Serialisation (state matching)
    \end{itemize}

  \item {\bf Update}
    \begin{itemize}
    \item Invoked by instruction execution
      \begin{itemize}
      \item Always
      \item Abstract value determines what dependencies it has.
      May save a considerable number of SMT invocations.

      \begin{figure}[!h]
      \centering
      \includegraphics{figure1}
      \end{figure}

      \FloatBarrier
      \end{itemize}
  \item Resolve all paths: defined $\Rightarrow$ add clause $\text{\tt path} = value$; undefined $\Rightarrow$ predicate undefined
  \item \ldots

    \begin{figure}[!h]
    \centering
    \includegraphics{figure2}
    \end{figure}

    \FloatBarrier

  \end{itemize}
\end{itemize}

\item Predicates evaluate to $\left\{ \begin{array}{lcl}\text{\tt undefined} &\sim& \text{\it referring to out-of-scope variables} \\ \text{\tt 0} &\sim& \text{\tt false} \\ \text{\tt 1} &\sim& \text{\tt true} \\ \text{\tt unknown (*)} &\sim& \text{\tt TOP} \end{array} \right. $

\begin{figure}[!h]
\centering
\includegraphics{figure0}
\end{figure}

\FloatBarrier

\item Mapping variables / class names to concrete ElementInfo / ClassInfo objects in concrete scope.

Needed to be able to provide SMT with fixed values of different variables (symbols).

  Choose one of:
  \begin{itemize}
  \item provide a dictionary of our own

    {\bf Pros:}
    \begin{itemize}
    \item Fast (Hash tables) or other dictionary-like structures instead of arrays
    \end{itemize}

    {\bf Cons:}
    \begin{itemize}
    \item Need to handle backtracking and scoping in general
    \end{itemize}
  \item extract needed information from ThreadInfo, StackFrame and VM
    \begin{itemize}
    \item {\bf Fields:} ThreadInfo.getElementInfo, StackFrame.getThis, ElementInfo.getClassInfo, ClassInfo.getInstanceField
    \item {\bf Locals:} StackFrame.getLocalVars
    \item {\bf Static:} VM.getClassLoaderList, ClassLoaderInfo.loadedClasses, ClassInfo.getStatics \ldots
    \end{itemize}
  \end{itemize}

\item SMT - invoked as a separate process

Use:
\begin{itemize}
\item at update of the abstract value
\item at branch choice
\end{itemize}

Choices:
\begin{itemize}
\item {\bf MathSAT 5} - accepts SMT-LIB format and DIMACS format
\item Yices
\item \ldots
\end{itemize}

\end{itemize}

\end{document}
