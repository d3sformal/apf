# project config for jpf-abstraction extension
# only process this properties file if on top of the jpf-core model classes

jpf-abstraction = ${config_path}

# we need to use ';' delimiters so that NetBeans/Ant can use this as a path spec
jpf-abstraction.native_classpath=\
  ${jpf-abstraction}/build/jpf-abstraction.jar;${jpf-abstraction}/lib/antlr-4.0-complete.jar

jpf-abstraction.classpath=\
  ${jpf-abstraction}/build/jpf-abstraction-classes.jar

#jpf-abstraction.test_classpath=\
#  ${jpf-abstraction}/build/tests/gov/nasa/jpf/abstraction

### configurations specific to the symbc project

# note we have to use the "+<key>=.." prepend notation since the NetBeans/Ant
# property parser doesn't like recursion
+peer_packages = gov.nasa.jpf.abstraction;

jvm.insn_factory.class=gov.nasa.jpf.abstraction.AbstractInstructionFactory

# no state matching
# vm.storage.class=nil

report.publisher=console
report.console.class=gov.nasa.jpf.abstraction.PredicateConsolePublisher
report.console.property_violation=error,snapshot,trace

# mandatory Search that allows abstraction refinement
search.class=gov.nasa.jpf.abstraction.PredicateAbstractionRefinementSearch

# mandatory Serializer that accounts for abstract states
vm.serializer.class=gov.nasa.jpf.abstraction.PredicateAbstractionSerializer

# more or less mandatory choice of StateSet when using refinement
vm.storage.class=gov.nasa.jpf.abstraction.ResetableStateSet

# enables various additional informative messages
panda.verbose=false

# stores everything sent to smt solvers in files prefixed with 'smt.'
panda.log_smt=false

# force assertions to be ENABLED, DISABLED, UNKNOWN-STATE
panda.assertions_disabled=false

# when reporting potential error trace, print concrete trace
panda.counterexample.print_concrete=true

# when reporting spurious error trace, print the trace and interpolants either SEPARATED or INTERLEAVED
panda.counterexample.print_format=SEPARATED

# when reporting spurious error trace, print the refined sets of abstraction predicates (grouped into method contexts)
panda.counterexample.print_refined_predicate_contexts=true

# report failures of refinement
panda.counterexample.print_error_on_refinement_failure=false

# when an abstractly enabled branch is not enabled concretely, adjust concrete state to match the abstract state and continue to the branch
# incompatible with panda.branch.prune_infeasible
panda.branch.adjust_concrete_values=true

# when an abstractly enabled branch is not enabled concretely, find a concrete trace that would enable the branch, add choices of non-det values to enable exploring the trace
# requires panda.branch.prune_infeasible
panda.branch.nondet_force_feasible=true

# implies panda.branch.force_feasible, uses state matching so that forcing branches enables each branch just once (guarantees convergence: exploring just one concrete trace corresponding to the abstract trace)
panda.branch.nondet_force_feasible_once=true

# branches that are not enabled concretely are cut off
# incompatible with panda.branch.adjust_concrete_values
panda.branch.prune_infeasible=false

# force refinement of predicate valuation after branching (improved precision based on assumed branch)
panda.branch.reevaluate_predicates=true

# enables lazy abstraction-like refinement of the abstraction
# - counterexample analysis using SMT
# - interpolants
panda.refinement=false

# treats the trace formula as a one large formula, does not account for method scopes
panda.refinement.global=false

# adds an overapproximation of the subtrace within a method as an abstraction predicate globally (for the method)
panda.refinement.method_global=true

# true: after refinement backtracks to first refined state and recomputes only the necessary part of the state space
# false: backtracks all the way to the initial state and recomputes the entire state space (unlike lazy abstraction)
panda.refinement.keep_unrefined_prefix=true

# add trace formula clauses that capture initial values of fields/elements
panda.refinement.initialize_static_fields=true
panda.refinement.initialize_object_fields=true
# initialization of array elements may result in "unsupported" response from the solver
panda.refinement.initialize_array_elements=false

# default implementation of the state set (which is wrapped by a resetable facade)
panda.storage.class=gov.nasa.jpf.vm.JenkinsStateSet

# do not use this unless debugging Panda itself
# forces all minimizations of expressions to be checked (equivalence with the original expression) for correctness by SMT
panda.language.check_minimization=false
